#include <iostream>

using namespace std;


// c++ const에 관한 기본 내용
int main() {
	const int a = 100;
	// 우리가 가장 보편적으로 많이 쓰는 형태 const 자료형 변수명 
	// a는 const가 붙음으로써 상수형태가 되고 이 값은 수정할 수 없다.
	 
	//a = 1000; // 빨간줄
	
	// 하지만 간접 참조를 통해 값을 바꾸는 것은 가능
	int* b = (int*)&a; // const int* 를 int*로 강제 형변환 한것. 바람직하지 않음
	*b = 200;


	// 여기서 문제 왜 그냥 a를 출력하면 100이 나오나요? - 워드파일 참고
	cout << "*b: " << *b << endl; // 200 실제로 a값도 200이 들어있음. 디버깅 모드를 통해 확인할 수 있다. 워드파일 참고
	cout << "a: " << a << endl; // 100

	// const 변수는 그렇다면 참조도 안되는건가요? -> No

	// int& b = a; 상수형 변수를 그냥 일반 레퍼런스로 참조하는 것은 불가능! --> 값을 바꿀 수 없기 때문에 참조도 막아버린다. 
	const int& c = a; // 하지만 const int& 를 통해 참조가 가능하다 --> 읽기만 가능 변수에 값을 쓰는 것은 마찬가지로 불가능하다
	// b = 1000 //  빨간줄
	cout << "c: " << c << endl; // 200 
	cout << endl;
	cout << endl;
//==================================================================================================================
	int d = 1000;
	int d1 = 2000;
	int* const e = &d; // const는 앞에 붙이는 것 뿐만 아니라 뒤에도 붙일 수가 있다

	cout << "변환 전 d: " << d << endl;
	*e = 10000; // 값도 정상적으로 수정 가능하다.
	cout << "변환 후 d: " << d << endl;

	// 이 친구는 정채가 뭔가요?
	// 이 친구는 d를 가르키는 주소값을 상수화 시키는 것.
	// 즉 현재 e가 d의 주소값을 담고 있을 때 e를 다시 d1을 가르키게 하고싶을 때 그 작업이 불가능하다.

	// e = d1; // 빨간줄

}